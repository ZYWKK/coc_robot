import time
from concurrent.futures import ThreadPoolExecutor

import cv2
import numpy as np

from 任务流程.基础任务框架 import 任务上下文, 基础任务
from 任务流程.进攻坐标逻辑计算 import 坐标, 判断目标点到可进攻边缘距离是否小于设定值
from 工具包.工具函数 import 打印运行耗时
from 模块.检测.OCR识别器 import 安全OCR引擎
from 模块.检测.YOLO检测器 import 线程安全YOLO检测器
from 模块.检测.模板匹配器 import 模板匹配引擎


class 搜索目标敌人任务(基础任务):
    """必须在找鱼的界面调用,也就是界面包含了敌人的村庄以及下一个按钮.自动搜索并评估敌人资源,和资源建筑位置，符合条件时返回"""
    def __init__(self):
        self.ocr引擎 = 安全OCR引擎()
        self.检测器 = 线程安全YOLO检测器()
        self.模板识别 = 模板匹配引擎()

    def 执行(self, 上下文: 任务上下文) -> bool:
        try:
            搜索次数 = 1
            最小资源 = 上下文.数据库.获取机器人设置(上下文.机器人标志).欲进攻的最小资源
            原始目标 = 最小资源

            while True:

                if  self.执行单次搜索(上下文, 搜索次数, 最小资源):
                    return True

                # 每10次降低目标
                if 搜索次数 % 10 == 0:
                    最小资源 = self.调整搜索目标(上下文, 原始目标, 搜索次数)

                搜索次数 += 1
                上下文.脚本延时(500)

        except Exception as e:
            self.异常处理(上下文, e)
            return False

    def 执行单次搜索(self, 上下文: 任务上下文, 搜索次数: int, 最小资源: int) -> bool:
        """执行单次搜索流程，返回是否找到合适目标"""
        if not self.等待下一个按钮出现(上下文):
            raise RuntimeError("未找到下一个按钮，可能已在战斗界面")

        资源数据 = self.识别当前资源(上下文)
        self.打印状态信息(上下文, 搜索次数, 资源数据)

        if 资源数据["总资源"] >= 最小资源:

            if self.是否有足够资源建筑靠近边缘(上下文, 80, 最少靠近比例=0.6):
                上下文.置脚本状态("成功找到敌人")
                return True
            else:
                上下文.置脚本状态("资源目标符合,但是不符合建筑靠近边缘目标,继续寻找")

        self.点击下一个按钮(上下文)
        return False

    def 打印状态信息(self, 上下文: 任务上下文, 搜索次数: int, 资源数据: dict):
        """更新状态信息"""
        状态信息 = (
            f"搜索次数[{搜索次数}] "
            f"金币[{资源数据['金币']}] "
            f"圣水[{资源数据['圣水']}] "
            f"黑油[{资源数据['黑油']}]"
        )
        上下文.置脚本状态(状态信息)

    def 是否有足够资源建筑靠近边缘(self,上下文,
            距离阈值: float,
            最少靠近数量: int = None,
            最少靠近比例: float = None,
            允许检测的类别: list = None,
            截图区域: tuple = (0, 0, 800, 600)
    ) -> bool:
        """
        判断是否存在足够数量（或比例）的金矿/圣水采集器靠近地图边缘。

        参数:
            距离阈值: float - 距离边缘小于此值时，视为“靠近边缘”
            最少靠近数量: int - 至少多少个靠近边缘（与比例二选一）
            最少靠近比例: float - 至少多少比例的目标靠近边缘（与数量二选一）
            允许检测的类别: list[str] - 默认为 ['金矿', '圣水采集器']
            截图区域: tuple - 截图区域 (x, y, 宽, 高)

        返回:
            bool - 是否达到靠近边缘的数量或比例条件
        """
        #YOLO检测器 = 线程安全YOLO检测器()
        if 允许检测的类别 is None:
            允许检测的类别 = ['金矿', '圣水采集器']

        if 最少靠近数量 is None and 最少靠近比例 is None:
            最少靠近数量 = 1  # 默认最少要一个目标靠近边缘

        左上x, 左上y, 宽, 高 = 截图区域
        全屏图像 = 上下文.op.获取屏幕图像cv(左上x, 左上y, 宽, 高)

        检测结果列表 = self.检测器.检测(全屏图像)

        总资源目标数量 = 0
        靠近边缘数量 = 0

        for 目标 in 检测结果列表:
            类别 = 目标['类别名称']
            if 类别 not in 允许检测的类别:
                continue

            总资源目标数量 += 1
            左, 上, 右, 下 = 目标['裁剪坐标']
            中心坐标 = 坐标((左 + 右) // 2, (上 + 下) // 2)

            if 判断目标点到可进攻边缘距离是否小于设定值(中心坐标, 距离阈值):
                靠近边缘数量 += 1


        上下文.置脚本状态("识别到的资源建筑数量为"+str(总资源目标数量)+"目前有"+str(靠近边缘数量)+"资源建筑靠近边缘")

        if 总资源目标数量 == 0:
            return False  # 没有可判断的目标

        if 最少靠近比例 is not None:
            实际比例 = 靠近边缘数量 / 总资源目标数量
            return 实际比例 >= 最少靠近比例

        # 否则按数量判断
        return 靠近边缘数量 >= 最少靠近数量

    def 等待下一个按钮出现(self, 上下文) -> bool:
        """使用模板匹配检测下一个按钮"""

        按钮区域 = (0, 0, 800, 600)
        模板路径 = "下一个.bmp"
        超时时间 = 30  # 秒
        开始时间 = time.time()

        while time.time() - 开始时间 < 超时时间:
            # 获取按钮区域图像
            屏幕图像 = 上下文.op.获取屏幕图像cv(*按钮区域)

            # 执行模板匹配
            是否匹配, (x, y) ,_ = self.模板识别.执行匹配(屏幕图像,模板路径,相似度阈值=0.9)
            if 是否匹配:
                return True

            # 间隔检测
            上下文.脚本延时(500)

        # 超时处理
        上下文.置脚本状态("等待下一个按钮超时,已经卡白云30秒了", 超时的时间=10)
        return False
    #
    # @打印运行耗时
    # def 识别当前资源(self, 上下文, ocr_引擎) -> dict:
    #     """优化后的资源识别方法"""
    #     try:
    #         全屏图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)
    #
    #         # 各资源区域坐标 (y1:y2, x1:x2)
    #         金币区域 = 全屏图像[67:87, 43:243]
    #         圣水区域 = 全屏图像[93:114, 44:250]
    #         黑油区域 = 全屏图像[115:147, 40:148]
    #
    #         # 并行OCR识别
    #         with ThreadPoolExecutor(max_workers=3) as pool:
    #             金币任务 = pool.submit(self.安全OCR识别, ocr_引擎, 金币区域)
    #             圣水任务 = pool.submit(self.安全OCR识别, ocr_引擎, 圣水区域)
    #             黑油任务 = pool.submit(self.安全OCR识别, ocr_引擎, 黑油区域)
    #
    #             金币文本 = 金币任务.result()
    #             圣水文本 = 圣水任务.result()
    #             黑油文本 = 黑油任务.result()
    #
    #         return {
    #             "金币": self.文本转数值(金币文本),
    #             "圣水": self.文本转数值(圣水文本),
    #             "黑油": self.文本转数值(黑油文本),
    #             "总资源": self.文本转数值(金币文本) + self.文本转数值(圣水文本)
    #         }
    #     except:
    #         return {"金币": 0, "圣水": 0, "黑油": 0, "总资源": 0}
    #
    # def 安全OCR识别(self, ocr_引擎, 图像区域) -> str:
    #     """带预处理的OCR识别"""
    #     try:
    #         # 图像预处理
    #         灰度图 = cv2.cvtColor(图像区域, cv2.COLOR_BGR2GRAY)
    #         _, 二值图 = cv2.threshold(灰度图, 180, 255, cv2.THRESH_BINARY_INV)
    #
    #         # OCR识别
    #         result, _ = ocr_引擎(二值图)
    #         return str(result[0][1]) if result else "0"
    #     except:
    #         return "0"
    @打印运行耗时
    def 识别当前资源(self, 上下文) -> dict:
        """修复后的资源识别方法"""
        try:

            # # 单次截取全屏图像（包含所有需要识别的区域）
            # 全屏图像 = 上下文.op.获取屏幕图像cv(0, 0, 800, 600)  # 根据实际屏幕大小调整
            #
            # # 从全屏图像中提取各资源区域
            # 金币区域 = 全屏图像[67:87, 43:243]  # y1:y2, x1:x2
            # 圣水区域 = 全屏图像[93:114, 44:250]  # 注意OpenCV的矩阵切片顺序
            # 黑油区域 = 全屏图像[115:147, 40:148]
            #
            # # OCR识别（添加空值保护）
            # 耗时开始时间 = time.time()
            # 金币结果, _ = self.ocr引擎(金币区域) if self.ocr引擎 else (None, 0)
            # 圣水结果, _ = self.ocr引擎(圣水区域) if self.ocr引擎 else (None, 0)
            # 黑油结果, _ = self.ocr引擎(黑油区域) if self.ocr引擎 else (None, 0)
            #
            # # 安全提取文本（示例OCR结果结构：[[[[坐标], 文本, 置信度], ...]]）
            # 金币文本 = str(金币结果[0][1]) if 金币结果 and len(金币结果) > 0 else "0"
            # 圣水文本 = str(圣水结果[0][1]) if 圣水结果 and len(圣水结果) > 0 else "0"
            # 黑油文本 = str(黑油结果[0][1]) if 黑油结果 and len(黑油结果) > 0 else "0"
            #

            全屏图像 = 上下文.op.获取屏幕图像cv(14,67,151,146)


            # 单次OCR识别（结果按顺序对应各区域）
            result, _ = self.ocr引擎(全屏图像)
            # 解析结果（假设OCR按行返回）
            金币文本 = str(result[0][1]) if len(result) > 0 else "0"
            圣水文本 = str(result[1][1]) if len(result) > 1 else "0"
            黑油文本 = str(result[2][1]) if len(result) > 2 else "0"



            return {
                "金币": self.文本转数值(金币文本),
                "圣水": self.文本转数值(圣水文本),
                "黑油": self.文本转数值(黑油文本),
                "总资源": self.文本转数值(金币文本) + self.文本转数值(圣水文本)
            }
        except Exception as e:
            上下文.置脚本状态(f"资源识别失败: {str(e)}")
            return {"金币": 0, "圣水": 0, "黑油": 0, "总资源": 0}

    def 文本转数值(self, 文本: str) -> int:
        """增强型文本转换"""
        try:
            # 处理常见OCR错误字符
            清理文本 = 文本.replace('O', '0').replace('o', '0').replace(' ', '')
            return int(''.join(filter(str.isdigit, 清理文本)))
        except:
            return 0  # 确保始终返回数值

    def 调整搜索目标(self, 上下文, 原始目标: int, 当前次数: int) -> int:
        """每10次降低搜索标准"""
        新目标 = max(原始目标 - int(原始目标 * 0.1), 100000)  # 最低不低于10万
        上下文.置脚本状态(
            f"搜索达{当前次数}次，降低目标至{新目标}",
            超时的时间=10
        )
        return 新目标

    def 点击下一个按钮(self, 上下文):
        """点击下一个按钮"""
        上下文.点击(694, 461)


    def 异常处理(self, 上下文: 任务上下文, 异常: Exception):
        super().异常处理(上下文, 异常)
        上下文.发送重启请求(f"搜索任务异常：{str(异常)}")